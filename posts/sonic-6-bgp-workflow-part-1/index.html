<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"r12f.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.16.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"flat"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="（以下内容已经整合进《SONiC入门指南》的 BGP工作流 ，BGP命令实现和BGP路由变更下发 三节中。） BGP可能是交换机里面最常用，最重要，或者线上使用的最多的功能了。这一篇，我们就来深入的看一下BGP相关的工作流。 1. BGP相关进程 SONiC使用FRRouting作为BGP的实现，用于负责BGP的协议处理。FRRouting是一个开源的路由软件，支持多种路由协议，包括BGP，OSP">
<meta property="og:type" content="article">
<meta property="og:title" content="SONiC学习笔记（六）：BGP工作流（上）—— 命令实现与FRR">
<meta property="og:url" content="http://r12f.com/posts/sonic-6-bgp-workflow-part-1/index.html">
<meta property="og:site_name" content="Soul Orbit">
<meta property="og:description" content="（以下内容已经整合进《SONiC入门指南》的 BGP工作流 ，BGP命令实现和BGP路由变更下发 三节中。） BGP可能是交换机里面最常用，最重要，或者线上使用的最多的功能了。这一篇，我们就来深入的看一下BGP相关的工作流。 1. BGP相关进程 SONiC使用FRRouting作为BGP的实现，用于负责BGP的协议处理。FRRouting是一个开源的路由软件，支持多种路由协议，包括BGP，OSP">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-07-02T17:48:21.000Z">
<meta property="article:modified_time" content="2023-07-02T17:48:21.000Z">
<meta property="article:author" content="r12f">
<meta property="article:tag" content="network">
<meta property="article:tag" content="nos">
<meta property="article:tag" content="sonic">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://r12f.com/posts/sonic-6-bgp-workflow-part-1/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://r12f.com/posts/sonic-6-bgp-workflow-part-1/","path":"posts/sonic-6-bgp-workflow-part-1/","title":"SONiC学习笔记（六）：BGP工作流（上）—— 命令实现与FRR"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>SONiC学习笔记（六）：BGP工作流（上）—— 命令实现与FRR | Soul Orbit</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-20527248-4"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-20527248-4","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Soul Orbit" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Soul Orbit</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">I'll take a quiet life. A handshake of carbon monoxide.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#BGP%E7%9B%B8%E5%85%B3%E8%BF%9B%E7%A8%8B"><span class="nav-text">1. BGP相关进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BGP%E5%91%BD%E4%BB%A4%E5%AE%9E%E7%8E%B0"><span class="nav-text">2. BGP命令实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BGP%E8%B7%AF%E7%94%B1%E5%8F%98%E6%9B%B4%E4%B8%8B%E5%8F%91"><span class="nav-text">3. BGP路由变更下发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#FRR%E5%A4%84%E7%90%86%E8%B7%AF%E7%94%B1%E5%8F%98%E6%9B%B4"><span class="nav-text">3.1. FRR处理路由变更</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#bgpd%E5%A4%84%E7%90%86%E8%B7%AF%E7%94%B1%E5%8F%98%E6%9B%B4"><span class="nav-text">3.1.1. bgpd处理路由变更</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#zebra%E6%9B%B4%E6%96%B0%E8%B7%AF%E7%94%B1%E8%A1%A8"><span class="nav-text">3.1.2. zebra更新路由表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#dplane%E6%9B%B4%E6%96%B0%E5%86%85%E6%A0%B8%E8%B7%AF%E7%94%B1%E8%A1%A8"><span class="nav-text">3.1.2.1. dplane更新内核路由表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FPM%E8%B7%AF%E7%94%B1%E6%9B%B4%E6%96%B0%E8%BD%AC%E5%8F%91"><span class="nav-text">3.1.2.2. FPM路由更新转发</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-text">4. 小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-text">5. 参考资料</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">r12f</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">72</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">102</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/r12f" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;r12f" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.youtube.com/channel/UCeWewreVD6kJo6KWFW_ekKg" title="YouTube → https:&#x2F;&#x2F;www.youtube.com&#x2F;channel&#x2F;UCeWewreVD6kJo6KWFW_ekKg" rel="noopener me" target="_blank"><i class="fab fa-youtube fa-fw"></i>YouTube</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          Links
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://www.qtmuniao.com/" title="https:&#x2F;&#x2F;www.qtmuniao.com&#x2F;" rel="noopener" target="_blank">青藤木鸟</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://muqix.github.io/" title="https:&#x2F;&#x2F;muqix.github.io&#x2F;" rel="noopener" target="_blank">民国文艺少女Muqi</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://wuhenqs.com/" title="http:&#x2F;&#x2F;wuhenqs.com&#x2F;" rel="noopener" target="_blank">无痕的碎碎念</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://victoryang00.cn/wordpress" title="https:&#x2F;&#x2F;victoryang00.cn&#x2F;wordpress" rel="noopener" target="_blank">victoryang</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://captdam.com/" title="https:&#x2F;&#x2F;captdam.com&#x2F;" rel="noopener" target="_blank">小明</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://r12f.com/posts/sonic-6-bgp-workflow-part-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="r12f">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Soul Orbit">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="SONiC学习笔记（六）：BGP工作流（上）—— 命令实现与FRR | Soul Orbit">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          SONiC学习笔记（六）：BGP工作流（上）—— 命令实现与FRR
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-07-02 10:48:21" itemprop="dateCreated datePublished" datetime="2023-07-02T10:48:21-07:00">2023-07-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/01-Binary-Life/" itemprop="url" rel="index"><span itemprop="name">01 Binary Life</span></a>
        </span>
    </span>

  
    <span id="/posts/sonic-6-bgp-workflow-part-1/" class="post-meta-item leancloud_visitors" data-flag-title="SONiC学习笔记（六）：BGP工作流（上）—— 命令实现与FRR" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/posts/sonic-6-bgp-workflow-part-1/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="posts/sonic-6-bgp-workflow-part-1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p><em>（以下内容已经整合进《SONiC入门指南》的 <a href="https://r12f.com/sonic-book/5-2-bgp-workflow.html">BGP工作流</a> ，<a href="https://r12f.com/sonic-book/5-2-1-bgp-command-impl.html">BGP命令实现</a>和<a href="https://r12f.com/sonic-book/5-2-2-bgp-route-update-workflow.html">BGP路由变更下发</a> 三节中。）</em></p>
<p><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc4271">BGP</a>可能是交换机里面最常用，最重要，或者线上使用的最多的功能了。这一篇，我们就来深入的看一下BGP相关的工作流。</p>
<h2 id="BGP相关进程">1. BGP相关进程</h2>
<p>SONiC使用<a target="_blank" rel="noopener" href="https://frrouting.org/">FRRouting</a>作为BGP的实现，用于负责BGP的协议处理。FRRouting是一个开源的路由软件，支持多种路由协议，包括BGP，OSPF，IS-IS，RIP，PIM，LDP等等。当FRR发布新版本后，SONiC会将其同步到<a target="_blank" rel="noopener" href="https://github.com/sonic-net/sonic-frr">SONiC的FRR实现仓库：sonic-frr</a>中，每一个版本都对应这一个分支，比如<code>frr/8.2</code>。</p>
<p>FRR主要由两个大部分组成，第一个部分是各个协议的实现，这些进程的名字都叫做<code>*d</code>，而当它们收到路由更新的通知的时候，就会告诉第二个部分，也就是<code>zebra</code>进程，然后<code>zebra</code>进程会进行选路，并将最优的路由信息同步到kernel中，其主体结构如下图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+----+  +----+  +-----+  +----+  +----+  +----+  +-----+</span><br><span class="line">|bgpd|  |ripd|  |ospfd|  |ldpd|  |pbrd|  |pimd|  |.....|</span><br><span class="line">+----+  +----+  +-----+  +----+  +----+  +----+  +-----+</span><br><span class="line">     |       |        |       |       |       |        |</span><br><span class="line">+----v-------v--------v-------v-------v-------v--------v</span><br><span class="line">|                                                      |</span><br><span class="line">|                         Zebra                        |</span><br><span class="line">|                                                      |</span><br><span class="line">+------------------------------------------------------+</span><br><span class="line">       |                    |                   |</span><br><span class="line">       |                    |                   |</span><br><span class="line">+------v------+   +---------v--------+   +------v------+</span><br><span class="line">|             |   |                  |   |             |</span><br><span class="line">| *NIX Kernel |   | Remote dataplane |   | ........... |</span><br><span class="line">|             |   |                  |   |             |</span><br><span class="line">+-------------+   +------------------+   +-------------+</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>在SONiC中，这些FRR的进程都跑在<code>bgp</code>的容器中。另外，为了将FRR和Redis连接起来，SONiC在<code>bgp</code>容器中还会运行一个叫做<code>fpgsyncd</code>的进程（Forwarding Plane Manager syncd），它的主要功能是监听kernel的路由更新，然后将其同步到APP_DB中。但是因为这个进程不是FRR的一部分，所以它的实现被放在了<a target="_blank" rel="noopener" href="https://github.com/sonic-net/sonic-swss">sonic-swss</a>仓库中。</p>
<h2 id="BGP命令实现">2. BGP命令实现</h2>
<p>由于BGP是使用FRR来实现的，所以自然而然的，<code>show</code>命令会将直接请求转发给FRR的<code>vtysh</code>，核心代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## file: src/sonic-utilities/show/bgp_frr_v4.py</span></span><br><span class="line"><span class="comment">## &#x27;summary&#x27; subcommand (&quot;show ip bgp summary&quot;)</span></span><br><span class="line"><span class="meta">@bgp.command()</span></span><br><span class="line"><span class="meta">@multi_asic_util.multi_asic_click_options</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">summary</span>(<span class="params">namespace, display</span>):</span><br><span class="line">    bgp_summary = bgp_util.get_bgp_summary_from_all_bgp_instances(</span><br><span class="line">        constants.IPV4, namespace, display)</span><br><span class="line">    bgp_util.display_bgp_summary(bgp_summary=bgp_summary, af=constants.IPV4)</span><br><span class="line"></span><br><span class="line"><span class="comment">## file: src/sonic-utilities/utilities_common/bgp_util.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_bgp_summary_from_all_bgp_instances</span>(<span class="params">af, namespace, display</span>):</span><br><span class="line">    <span class="comment"># IPv6 case is emitted here for simplicity</span></span><br><span class="line">    vtysh_cmd = <span class="string">&quot;show ip bgp summary json&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> ns <span class="keyword">in</span> device.get_ns_list_based_on_options():</span><br><span class="line">        cmd_output = run_bgp_show_command(vtysh_cmd, ns)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_bgp_command</span>(<span class="params">vtysh_cmd, bgp_namespace=multi_asic.DEFAULT_NAMESPACE, vtysh_shell_cmd=constants.VTYSH_COMMAND</span>):</span><br><span class="line">    cmd = [<span class="string">&#x27;sudo&#x27;</span>, vtysh_shell_cmd] + bgp_instance_id + [<span class="string">&#x27;-c&#x27;</span>, vtysh_cmd]</span><br><span class="line">    output, ret = clicommon.run_command(cmd, return_cmd=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>这里，我们也可以通过直接运行<code>vtysh</code>来进行验证：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">root@7260cx3:/etc/sonic/frr<span class="comment"># which vtysh</span></span><br><span class="line">/usr/bin/vtysh</span><br><span class="line"></span><br><span class="line">root@7260cx3:/etc/sonic/frr<span class="comment"># vtysh</span></span><br><span class="line"></span><br><span class="line">Hello, this is FRRouting (version 7.5.1-sonic).</span><br><span class="line">Copyright 1996-2005 Kunihiro Ishiguro, et al.</span><br><span class="line"></span><br><span class="line">7260cx3<span class="comment"># show ip bgp summary</span></span><br><span class="line"></span><br><span class="line">IPv4 Unicast Summary:</span><br><span class="line">BGP router identifier 10.1.0.32, <span class="built_in">local</span> AS number 65100 vrf-id 0</span><br><span class="line">BGP table version 6410</span><br><span class="line">RIB entries 12809, using 2402 KiB of memory</span><br><span class="line">Peers 4, using 85 KiB of memory</span><br><span class="line">Peer <span class="built_in">groups</span> 4, using 256 bytes of memory</span><br><span class="line"></span><br><span class="line">Neighbor        V         AS   MsgRcvd   MsgSent   TblVer  InQ OutQ  Up/Down State/PfxRcd   PfxSnt</span><br><span class="line">10.0.0.57       4      64600      3702      3704        0    0    0 08:15:03         6401     6406</span><br><span class="line">10.0.0.59       4      64600      3702      3704        0    0    0 08:15:03         6401     6406</span><br><span class="line">10.0.0.61       4      64600      3705      3702        0    0    0 08:15:03         6401     6406</span><br><span class="line">10.0.0.63       4      64600      3702      3702        0    0    0 08:15:03         6401     6406</span><br><span class="line"></span><br><span class="line">Total number of neighbors 4</span><br></pre></td></tr></table></figure>
<p>而<code>config</code>命令则是通过直接操作CONFIG_DB来实现的，核心代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## file: src/sonic-utilities/config/main.py</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@bgp.group(<span class="params">cls=clicommon.AbbreviationGroup</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remove</span>():</span><br><span class="line">    <span class="string">&quot;Remove BGP neighbor configuration from the device&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@remove.command(<span class="params"><span class="string">&#x27;neighbor&#x27;</span></span>)</span></span><br><span class="line"><span class="meta">@click.argument(<span class="params"><span class="string">&#x27;neighbor_ip_or_hostname&#x27;</span>, metavar=<span class="string">&#x27;&lt;neighbor_ip_or_hostname&gt;&#x27;</span>, required=<span class="literal">True</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remove_neighbor</span>(<span class="params">neighbor_ip_or_hostname</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Deletes BGP neighbor configuration of given hostname or ip from devices</span></span><br><span class="line"><span class="string">       User can specify either internal or external BGP neighbor to remove</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    namespaces = [DEFAULT_NAMESPACE]</span><br><span class="line">    removed_neighbor = <span class="literal">False</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Connect to CONFIG_DB in linux host (in case of single ASIC) or CONFIG_DB in all the</span></span><br><span class="line">    <span class="comment"># namespaces (in case of multi ASIC) and do the sepcified &quot;action&quot; on the BGP neighbor(s)</span></span><br><span class="line">    <span class="keyword">for</span> namespace <span class="keyword">in</span> namespaces:</span><br><span class="line">        config_db = ConfigDBConnector(use_unix_socket_path=<span class="literal">True</span>, namespace=namespace)</span><br><span class="line">        config_db.connect()</span><br><span class="line">        <span class="keyword">if</span> _remove_bgp_neighbor_config(config_db, neighbor_ip_or_hostname):</span><br><span class="line">            removed_neighbor = <span class="literal">True</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<h2 id="BGP路由变更下发">3. BGP路由变更下发</h2>
<p>路由变更几乎是SONiC中最重要的工作流，它的整个流程从<code>bgpd</code>进程开始，到最终通过SAI到达ASIC芯片，中间参与的进程较多，流程也较为复杂，但是弄清楚之后，我们就可以很好的理解SONiC的设计思想，并且举一反三的理解其他配置下发的工作流了。所以这一节，我们就一起来深入的分析一下它的整体流程。</p>
<p>为了方便我们理解和从代码层面来展示，我们把这个流程分成两个大块来介绍，分别是FRR是如何处理路由变化的，和SONiC的路由变更工作流以及它是如何与FRR进行整合的。</p>
<h3 id="FRR处理路由变更">3.1. FRR处理路由变更</h3>
<pre><code class="highlight mermaid">sequenceDiagram
    autonumber
    participant N as 邻居节点
    box lightblue bgp容器
    participant B as bgpd
    participant ZH as zebra&lt;br/&gt;（请求处理线程）
    participant ZF as zebra&lt;br/&gt;（路由处理线程）
    participant ZD as zebra&lt;br/&gt;（数据平面处理线程）
    participant ZFPM as zebra&lt;br/&gt;（FPM转发线程）
    participant FPM as fpmsyncd
    end
    participant K as Linux Kernel

    N-&gt;&gt;B: 建立BGP会话，&lt;br/&gt;发送路由变更
    B-&gt;&gt;B: 选路，变更本地路由表（RIB）
    alt 如果路由发生变化
    B-&gt;&gt;N: 通知其他邻居节点路由变化
    end
    B-&gt;&gt;ZH: 通过zlient本地Socket&lt;br/&gt;通知Zebra更新路由表
    ZH-&gt;&gt;ZH: 接受bgpd发送的请求
    ZH-&gt;&gt;ZF: 将路由请求放入&lt;br/&gt;路由处理线程的队列中
    ZF-&gt;&gt;ZF: 更新本地路由表（RIB）
    ZF-&gt;&gt;ZD: 将路由表更新请求放入&lt;br/&gt;数据平面处理线程&lt;br/&gt;的消息队列中
    ZF-&gt;&gt;ZFPM: 请求FPM处理线程转发路由变更
    ZFPM-&gt;&gt;FPM: 通过FPM协议通知&lt;br/&gt;fpmsyncd下发&lt;br/&gt;路由变更
    ZD-&gt;&gt;K: 发送Netlink消息更新内核路由表</code></pre>
<blockquote>
<p>关于FRR的实现，这里更多的是从代码的角度来阐述其工作流的过程，而不是其对BGP的实现细节，如果想要了解FRR的BGP实现细节，可以参考<a target="_blank" rel="noopener" href="https://docs.frrouting.org/en/latest/bgp.html">官方文档</a>。</p>
</blockquote>
<h4 id="bgpd处理路由变更">3.1.1. bgpd处理路由变更</h4>
<p><code>bgpd</code>是FRR中专门用来处理BGP会话的进程，它会开放TCP 179端口与邻居节点建立BGP连接，并处理路由表的更新请求。当路由发生变化后，FRR也会通过它来通知其他邻居节点。</p>
<p>请求来到<code>bgpd</code>之后，它会首先来到它的io线程：<code>bgp_io</code>。顾名思义，<code>bgpd</code>中的网络读写工作都是在这个线程上完成的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: src/sonic-frr/frr/bgpd/bgp_io.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">bgp_process_reads</span><span class="params">(<span class="keyword">struct</span> thread *thread)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (more) &#123;</span><br><span class="line">        <span class="comment">// Read packets here</span></span><br><span class="line">        ...</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// If we have more than 1 complete packet, mark it and process it later.</span></span><br><span class="line">        <span class="keyword">if</span> (ringbuf_remain(ibw) &gt;= pktsize) &#123;</span><br><span class="line">            ...</span><br><span class="line">            added_pkt = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (added_pkt)</span><br><span class="line">        thread_add_event(bm-&gt;master, bgp_process_packet, peer, <span class="number">0</span>, &amp;peer-&gt;t_process_packet);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当数据包读完后，<code>bgpd</code>会将其发送到主线程进行路由处理。在这里，<code>bgpd</code>会根据数据包的类型进行分发，其中路由更新的请求会交给<code>bpg_update_receive</code>来进行解析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: src/sonic-frr/frr/bgpd/bgp_packet.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bgp_process_packet</span><span class="params">(<span class="keyword">struct</span> thread *thread)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> processed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (processed &lt; rpkt_quanta_old) &#123;</span><br><span class="line">        <span class="type">uint8_t</span> type = <span class="number">0</span>;</span><br><span class="line">        <span class="type">bgp_size_t</span> size;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* read in the packet length and type */</span></span><br><span class="line">        size = stream_getw(peer-&gt;curr);</span><br><span class="line">        type = stream_getc(peer-&gt;curr);</span><br><span class="line">        size -= BGP_HEADER_SIZE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> BGP_MSG_OPEN:</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BGP_MSG_UPDATE:</span><br><span class="line">            ...</span><br><span class="line">            mprc = bgp_update_receive(peer, size);</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process BGP UPDATE message for peer.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">bgp_update_receive</span><span class="params">(<span class="keyword">struct</span> peer *peer, <span class="type">bgp_size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stream</span> *<span class="title">s</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attr</span> <span class="title">attr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bgp_nlri</span> <span class="title">nlris</span>[<span class="title">NLRI_TYPE_MAX</span>];</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse attributes and NLRI</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;attr, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> attr));</span><br><span class="line">    attr.label_index = BGP_INVALID_LABEL_INDEX;</span><br><span class="line">    attr.label = MPLS_INVALID_LABEL;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;nlris, <span class="number">0</span>, <span class="keyword">sizeof</span>(nlris));</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((!update_len &amp;&amp; !withdraw_len &amp;&amp; nlris[NLRI_MP_UPDATE].length == <span class="number">0</span>)</span><br><span class="line">        || (attr_parse_ret == BGP_ATTR_PARSE_EOR)) &#123;</span><br><span class="line">        <span class="comment">// More parsing here</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (afi &amp;&amp; peer-&gt;afc[afi][safi]) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">vrf</span> *<span class="title">vrf</span> =</span> vrf_lookup_by_id(peer-&gt;bgp-&gt;vrf_id);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* End-of-RIB received */</span></span><br><span class="line">            <span class="keyword">if</span> (!CHECK_FLAG(peer-&gt;af_sflags[afi][safi], PEER_STATUS_EOR_RECEIVED)) &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">if</span> (gr_info-&gt;eor_required == gr_info-&gt;eor_received) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                    <span class="comment">/* Best path selection */</span></span><br><span class="line">                    <span class="keyword">if</span> (bgp_best_path_select_defer( peer-&gt;bgp, afi, safi) &lt; <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> BGP_Stop;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Receive_UPDATE_message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，<code>bgpd</code>会开始检查是否出现更优的路径，并更新自己的本地路由表（RIB，Routing Information Base）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: src/sonic-frr/frr/bgpd/bgp_route.c</span></span><br><span class="line"><span class="comment">/* Process the routes with the flag BGP_NODE_SELECT_DEFER set */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bgp_best_path_select_defer</span><span class="params">(<span class="keyword">struct</span> bgp *bgp, <span class="type">afi_t</span> afi, <span class="type">safi_t</span> safi)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bgp_dest</span> *<span class="title">dest</span>;</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">afi_safi_info</span> *<span class="title">thread_info</span>;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Process the route list */</span></span><br><span class="line">    <span class="keyword">for</span> (dest = bgp_table_top(bgp-&gt;rib[afi][safi]);</span><br><span class="line">         dest &amp;&amp; bgp-&gt;gr_info[afi][safi].gr_deferred != <span class="number">0</span>;</span><br><span class="line">         dest = bgp_route_next(dest))</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        bgp_process_main_one(bgp, dest, afi, safi);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">bgp_process_main_one</span><span class="params">(<span class="keyword">struct</span> bgp *bgp, <span class="keyword">struct</span> bgp_dest *dest, <span class="type">afi_t</span> afi, <span class="type">safi_t</span> safi)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bgp_path_info</span> *<span class="title">new_select</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bgp_path_info</span> *<span class="title">old_select</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bgp_path_info_pair</span> <span class="title">old_and_new</span>;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">prefix</span> *<span class="title">p</span> =</span> bgp_dest_get_prefix(dest);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Best path selection. */</span></span><br><span class="line">    bgp_best_selection(bgp, dest, &amp;bgp-&gt;maxpaths[afi][safi], &amp;old_and_new, afi, safi);</span><br><span class="line">    old_select = old_and_new.old;</span><br><span class="line">    new_select = old_and_new.new;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* FIB update. */</span></span><br><span class="line">    <span class="keyword">if</span> (bgp_fibupd_safi(safi) &amp;&amp; (bgp-&gt;inst_type != BGP_INSTANCE_TYPE_VIEW)</span><br><span class="line">        &amp;&amp; !bgp_option_check(BGP_OPT_NO_FIB)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (new_select &amp;&amp; new_select-&gt;type == ZEBRA_ROUTE_BGP</span><br><span class="line">            &amp;&amp; (new_select-&gt;sub_type == BGP_ROUTE_NORMAL</span><br><span class="line">            || new_select-&gt;sub_type == BGP_ROUTE_AGGREGATE</span><br><span class="line">            || new_select-&gt;sub_type == BGP_ROUTE_IMPORTED)) &#123;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (old_select &amp;&amp; is_route_parent_evpn(old_select))</span><br><span class="line">                bgp_zebra_withdraw(p, old_select, bgp, safi);</span><br><span class="line"></span><br><span class="line">            bgp_zebra_announce(dest, p, new_select, bgp, afi, safi);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Withdraw the route from the kernel. */</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* EVPN route injection and clean up */</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    UNSET_FLAG(dest-&gt;flags, BGP_NODE_PROCESS_SCHEDULED);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，<code>bgp_zebra_announce</code>会通过<code>zclient</code>通知<code>zebra</code>更新内核路由表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: src/sonic-frr/frr/bgpd/bgp_zebra.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bgp_zebra_announce</span><span class="params">(<span class="keyword">struct</span> bgp_node *rn, <span class="keyword">struct</span> prefix *p, <span class="keyword">struct</span> bgp_path_info *info, <span class="keyword">struct</span> bgp *bgp, <span class="type">afi_t</span> afi, <span class="type">safi_t</span> safi)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    zclient_route_send(valid_nh_count ? ZEBRA_ROUTE_ADD : ZEBRA_ROUTE_DELETE, zclient, &amp;api);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>zclient</code>使用本地socket与<code>zebra</code>通信，并且提供一系列的回调函数用于接收<code>zebra</code>的通知，核心代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: src/sonic-frr/frr/bgpd/bgp_zebra.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bgp_zebra_init</span><span class="params">(<span class="keyword">struct</span> thread_master *master, <span class="type">unsigned</span> <span class="type">short</span> instance)</span></span><br><span class="line">&#123;</span><br><span class="line">    zclient_num_connects = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set default values. */</span></span><br><span class="line">    zclient = zclient_new(master, &amp;zclient_options_default);</span><br><span class="line">    zclient_init(zclient, ZEBRA_ROUTE_BGP, <span class="number">0</span>, &amp;bgpd_privs);</span><br><span class="line">    zclient-&gt;zebra_connected = bgp_zebra_connected;</span><br><span class="line">    zclient-&gt;router_id_update = bgp_router_id_update;</span><br><span class="line">    zclient-&gt;interface_add = bgp_interface_add;</span><br><span class="line">    zclient-&gt;interface_delete = bgp_interface_delete;</span><br><span class="line">    zclient-&gt;interface_address_add = bgp_interface_address_add;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">zclient_socket_connect</span><span class="params">(<span class="keyword">struct</span> zclient *zclient)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    sock = socket(zclient_addr.ss_family, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Connect to zebra. */</span></span><br><span class="line">    ret = connect(sock, (<span class="keyword">struct</span> sockaddr *)&amp;zclient_addr, zclient_addr_len);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    zclient-&gt;sock = sock;</span><br><span class="line">    <span class="keyword">return</span> sock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>bgpd</code>容器中，我们可以在<code>/run/frr</code>目录下找到<code>zebra</code>通信使用的socket文件来进行简单的验证：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@7260cx3:/run/frr<span class="comment"># ls -l</span></span><br><span class="line">total 12</span><br><span class="line">...</span><br><span class="line">srwx------ 1 frr frr    0 Jun 16 09:16 zserv.api</span><br></pre></td></tr></table></figure>
<h4 id="zebra更新路由表">3.1.2. zebra更新路由表</h4>
<p>由于FRR支持的路由协议很多，如果每个路由协议处理进程都单独的对内核进行操作则必然会产生冲突，很难协调合作，所以FRR使用一个单独的进程用于和所有的路由协议处理进程进行沟通，整合好信息之后统一的进行内核的路由表更新，这个进程就是<code>zebra</code>。</p>
<p>在<code>zebra</code>中，内核的更新发生在一个独立的数据面处理线程中：<code>dplane_thread</code>。所有的请求都会通过<code>zclient</code>发送给<code>zebra</code>，经过处理之后，最后转发给<code>dplane_thread</code>来处理，这样路由的处理就是有序的了，也就不会产生冲突了。</p>
<p><code>zebra</code>启动时，会将所有的请求处理函数进行注册，当请求到来时，就可以根据请求的类型调用相应的处理函数了，核心代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: src/sonic-frr/frr/zebra/zapi_msg.c</span></span><br><span class="line"><span class="type">void</span> (*zserv_handlers[])(ZAPI_HANDLER_ARGS) = &#123;</span><br><span class="line">    [ZEBRA_ROUTER_ID_ADD] = zread_router_id_add,</span><br><span class="line">    [ZEBRA_ROUTER_ID_DELETE] = zread_router_id_delete,</span><br><span class="line">    [ZEBRA_INTERFACE_ADD] = zread_interface_add,</span><br><span class="line">    [ZEBRA_INTERFACE_DELETE] = zread_interface_delete,</span><br><span class="line">    [ZEBRA_ROUTE_ADD] = zread_route_add,</span><br><span class="line">    [ZEBRA_ROUTE_DELETE] = zread_route_del,</span><br><span class="line">    [ZEBRA_REDISTRIBUTE_ADD] = zebra_redistribute_add,</span><br><span class="line">    [ZEBRA_REDISTRIBUTE_DELETE] = zebra_redistribute_delete,</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>我们这里拿添加路由<code>zread_route_add</code>作为例子，来继续分析后续的流程。从以下代码我们可以看到，当新的路由到来后，<code>zebra</code>会开始查看并更新自己内部的路由表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: src/sonic-frr/frr/zebra/zapi_msg.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">zread_route_add</span><span class="params">(ZAPI_HANDLER_ARGS)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stream</span> *<span class="title">s</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">route_entry</span> *<span class="title">re</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nexthop_group</span> *<span class="title">ng</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nhg_hash_entry</span> <span class="title">nhe</span>;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decode zclient request</span></span><br><span class="line">    s = msg;</span><br><span class="line">    <span class="keyword">if</span> (zapi_route_decode(s, &amp;api) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate new route entry.</span></span><br><span class="line">    re = XCALLOC(MTYPE_RE, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> route_entry));</span><br><span class="line">    re-&gt;type = api.type;</span><br><span class="line">    re-&gt;instance = api.instance;</span><br><span class="line">    ...</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Init nexthop entry, if we have an id, then add route.</span></span><br><span class="line">    <span class="keyword">if</span> (!re-&gt;nhe_id) &#123;</span><br><span class="line">        zebra_nhe_init(&amp;nhe, afi, ng-&gt;nexthop);</span><br><span class="line">        nhe.nhg.nexthop = ng-&gt;nexthop;</span><br><span class="line">        nhe.backup_info = bnhg;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = rib_add_multipath_nhe(afi, api.safi, &amp;api.prefix, src_p, re, &amp;nhe);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update stats. IPv6 is emitted here for simplicity.</span></span><br><span class="line">    <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) client-&gt;v4_route_add_cnt++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) client-&gt;v4_route_upd8_cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// File: src/sonic-frr/frr/zebra/zebra_rib.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rib_add_multipath_nhe</span><span class="params">(<span class="type">afi_t</span> afi, <span class="type">safi_t</span> safi, <span class="keyword">struct</span> prefix *p,</span></span><br><span class="line"><span class="params">              <span class="keyword">struct</span> prefix_ipv6 *src_p, <span class="keyword">struct</span> route_entry *re,</span></span><br><span class="line"><span class="params">              <span class="keyword">struct</span> nhg_hash_entry *re_nhe)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nhg_hash_entry</span> *<span class="title">nhe</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">route_table</span> *<span class="title">table</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">route_node</span> *<span class="title">rn</span>;</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Find table and nexthop entry */</span></span><br><span class="line">    table = zebra_vrf_get_table_with_table_id(afi, safi, re-&gt;vrf_id, re-&gt;table);</span><br><span class="line">    <span class="keyword">if</span> (re-&gt;nhe_id &gt; <span class="number">0</span>) nhe = zebra_nhg_lookup_id(re-&gt;nhe_id);</span><br><span class="line">    <span class="keyword">else</span> nhe = zebra_nhg_rib_find_nhe(re_nhe, afi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Attach the re to the nhe&#x27;s nexthop group. */</span></span><br><span class="line">    route_entry_update_nhe(re, nhe);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make it sure prefixlen is applied to the prefix. */</span></span><br><span class="line">    <span class="comment">/* Set default distance by route type. */</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Lookup route node.*/</span></span><br><span class="line">    rn = srcdest_rnode_get(table, p, src_p);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If this route is kernel/connected route, notify the dataplane to update kernel route table. */</span></span><br><span class="line">    <span class="keyword">if</span> (RIB_SYSTEM_ROUTE(re)) &#123;</span><br><span class="line">        dplane_sys_route_add(rn, re);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Link new re to node. */</span></span><br><span class="line">    SET_FLAG(re-&gt;status, ROUTE_ENTRY_CHANGED);</span><br><span class="line">    rib_addnode(rn, re, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Clean up */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>rib_addnode</code>会将这个路由添加请求转发给rib的处理线程，并由它顺序的进行处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">rib_addnode</span><span class="params">(<span class="keyword">struct</span> route_node *rn, <span class="keyword">struct</span> route_entry *re, <span class="type">int</span> process)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">rib_link</span>(rn, re, process);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">rib_link</span><span class="params">(<span class="keyword">struct</span> route_node *rn, <span class="keyword">struct</span> route_entry *re, <span class="type">int</span> process)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">rib_dest_t</span> *dest = <span class="built_in">rib_dest_from_rnode</span>(rn);</span><br><span class="line">    <span class="keyword">if</span> (!dest) dest = <span class="built_in">zebra_rib_create_dest</span>(rn);</span><br><span class="line">    <span class="built_in">re_list_add_head</span>(&amp;dest-&gt;routes, re);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (process) <span class="built_in">rib_queue_add</span>(rn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请求会来到RIB的处理线程：<code>rib_process</code>，并由它来进行进一步的选路，然后将最优的路由添加到<code>zebra</code>的内部路由表（RIB）中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Core function for processing routing information base. */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">rib_process</span><span class="params">(<span class="keyword">struct</span> route_node *rn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">route_entry</span> *re;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">route_entry</span> *next;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">route_entry</span> *old_selected = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">route_entry</span> *new_selected = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">route_entry</span> *old_fib = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">route_entry</span> *new_fib = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">route_entry</span> *best = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">rib_dest_t</span> *dest;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    dest = <span class="built_in">rib_dest_from_rnode</span>(rn);</span><br><span class="line">    old_fib = dest-&gt;selected_fib;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check every route entry and select the best route. */</span></span><br><span class="line">    <span class="built_in">RNODE_FOREACH_RE_SAFE</span> (rn, re, next) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">CHECK_FLAG</span>(re-&gt;flags, ZEBRA_FLAG_FIB_OVERRIDE)) &#123;</span><br><span class="line">            best = <span class="built_in">rib_choose_best</span>(new_fib, re);</span><br><span class="line">            <span class="keyword">if</span> (new_fib &amp;&amp; best != new_fib)</span><br><span class="line">                <span class="built_in">UNSET_FLAG</span>(new_fib-&gt;status, ROUTE_ENTRY_CHANGED);</span><br><span class="line">            new_fib = best;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            best = <span class="built_in">rib_choose_best</span>(new_selected, re);</span><br><span class="line">            <span class="keyword">if</span> (new_selected &amp;&amp; best != new_selected)</span><br><span class="line">                <span class="built_in">UNSET_FLAG</span>(new_selected-&gt;status, ROUTE_ENTRY_CHANGED);</span><br><span class="line">            new_selected = best;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (best != re)</span><br><span class="line">            <span class="built_in">UNSET_FLAG</span>(re-&gt;status, ROUTE_ENTRY_CHANGED);</span><br><span class="line">    &#125; <span class="comment">/* RNODE_FOREACH_RE */</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Update fib according to selection results */</span></span><br><span class="line">    <span class="keyword">if</span> (new_fib &amp;&amp; old_fib)</span><br><span class="line">        <span class="built_in">rib_process_update_fib</span>(zvrf, rn, old_fib, new_fib);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (new_fib)</span><br><span class="line">        <span class="built_in">rib_process_add_fib</span>(zvrf, rn, new_fib);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (old_fib)</span><br><span class="line">        <span class="built_in">rib_process_del_fib</span>(zvrf, rn, old_fib);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Remove all RE entries queued for removal */</span></span><br><span class="line">    <span class="comment">/* Check if the dest can be deleted now.  */</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于新的路由，会调用<code>rib_process_add_fib</code>来将其添加到<code>zebra</code>的内部路由表中，然后通知dplane进行内核路由表的更新：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">rib_process_add_fib</span><span class="params">(<span class="keyword">struct</span> zebra_vrf *zvrf, <span class="keyword">struct</span> route_node *rn, <span class="keyword">struct</span> route_entry *<span class="keyword">new</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">hook_call</span>(rib_update, rn, <span class="string">&quot;new route selected&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If labeled-unicast route, install transit LSP. */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">zebra_rib_labeled_unicast</span>(<span class="keyword">new</span>))</span><br><span class="line">        <span class="built_in">zebra_mpls_lsp_install</span>(zvrf, rn, <span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">rib_install_kernel</span>(rn, <span class="keyword">new</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">UNSET_FLAG</span>(<span class="keyword">new</span>-&gt;status, ROUTE_ENTRY_CHANGED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rib_install_kernel</span><span class="params">(<span class="keyword">struct</span> route_node *rn, <span class="keyword">struct</span> route_entry *re,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">struct</span> route_entry *old)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rib_table_info</span> *info = <span class="built_in">srcdest_rnode_table_info</span>(rn);</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">zebra_dplane_result</span> ret;</span><br><span class="line">    <span class="type">rib_dest_t</span> *dest = <span class="built_in">rib_dest_from_rnode</span>(rn);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Install the resolved nexthop object first. */</span></span><br><span class="line">    <span class="built_in">zebra_nhg_install_kernel</span>(re-&gt;nhe);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If this is a replace to a new RE let the originator of the RE know that they&#x27;ve lost */</span></span><br><span class="line">    <span class="keyword">if</span> (old &amp;&amp; (old != re) &amp;&amp; (old-&gt;type != re-&gt;type))</span><br><span class="line">        <span class="built_in">zsend_route_notify_owner</span>(rn, old, ZAPI_ROUTE_BETTER_ADMIN_WON, info-&gt;afi, info-&gt;safi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Update fib selection */</span></span><br><span class="line">    dest-&gt;selected_fib = re;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure we update the FPM any time we send new information to the kernel. */</span></span><br><span class="line">    <span class="built_in">hook_call</span>(rib_update, rn, <span class="string">&quot;installing in kernel&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Send add or update */</span></span><br><span class="line">    <span class="keyword">if</span> (old) ret = <span class="built_in">dplane_route_update</span>(rn, re, old);</span><br><span class="line">    <span class="keyword">else</span> ret = <span class="built_in">dplane_route_add</span>(rn, re);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有两个重要的操作，一个自然是调用<code>dplane_route_*</code>函数来进行内核的路由表更新，另一个则是出现了两次的<code>hook_call</code>，fpm的钩子函数就是挂在这个地方，用来接收并转发路由表的更新通知。这里我们一个一个来看：</p>
<h5 id="dplane更新内核路由表">3.1.2.1. dplane更新内核路由表</h5>
<p>首先是dplane的<code>dplane_route_*</code>函数，它们的做的事情都一样：把请求打包，然后放入<code>dplane_thread</code>的消息队列中，并不会做任何实质的操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: src/sonic-frr/frr/zebra/zebra_dplane.c</span></span><br><span class="line"><span class="keyword">enum</span> zebra_dplane_result <span class="title function_">dplane_route_add</span><span class="params">(<span class="keyword">struct</span> route_node *rn, <span class="keyword">struct</span> route_entry *re)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> dplane_route_update_internal(rn, re, <span class="literal">NULL</span>, DPLANE_OP_ROUTE_INSTALL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> zebra_dplane_result <span class="title function_">dplane_route_update</span><span class="params">(<span class="keyword">struct</span> route_node *rn, <span class="keyword">struct</span> route_entry *re, <span class="keyword">struct</span> route_entry *old_re)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> dplane_route_update_internal(rn, re, old_re, DPLANE_OP_ROUTE_UPDATE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> zebra_dplane_result <span class="title function_">dplane_sys_route_add</span><span class="params">(<span class="keyword">struct</span> route_node *rn, <span class="keyword">struct</span> route_entry *re)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> dplane_route_update_internal(rn, re, <span class="literal">NULL</span>, DPLANE_OP_SYS_ROUTE_ADD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">enum</span> zebra_dplane_result</span><br><span class="line"><span class="title function_">dplane_route_update_internal</span><span class="params">(<span class="keyword">struct</span> route_node *rn, <span class="keyword">struct</span> route_entry *re, <span class="keyword">struct</span> route_entry *old_re, <span class="keyword">enum</span> dplane_op_e op)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">zebra_dplane_result</span> <span class="title">result</span> =</span> ZEBRA_DPLANE_REQUEST_FAILURE;</span><br><span class="line">    <span class="type">int</span> ret = EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create and init context */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zebra_dplane_ctx</span> *<span class="title">ctx</span> =</span> ...;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Enqueue context for processing */</span></span><br><span class="line">    ret = dplane_route_enqueue(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Update counter */</span></span><br><span class="line">    atomic_fetch_add_explicit(&amp;zdplane_info.dg_routes_in, <span class="number">1</span>, memory_order_relaxed);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret == AOK)</span><br><span class="line">        result = ZEBRA_DPLANE_REQUEST_QUEUED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们就来到了数据面处理线程<code>dplane_thread</code>，其消息循环很简单，就是从队列中一个个取出消息，然后通过调用其处理函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: src/sonic-frr/frr/zebra/zebra_dplane.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dplane_thread_loop</span><span class="params">(<span class="keyword">struct</span> thread *event)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (prov) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Process work here */</span></span><br><span class="line">        (*prov-&gt;dp_fp)(prov);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check for zebra shutdown */</span></span><br><span class="line">        <span class="comment">/* Dequeue completed work from the provider */</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Locate next provider */</span></span><br><span class="line">        DPLANE_LOCK();</span><br><span class="line">        prov = TAILQ_NEXT(prov, dp_prov_link);</span><br><span class="line">        DPLANE_UNLOCK();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，<code>dplane_thread</code>会使用<code>kernel_dplane_process_func</code>来进行消息的处理，内部会根据请求的类型对内核的操作进行分发：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">kernel_dplane_process_func</span><span class="params">(<span class="keyword">struct</span> zebra_dplane_provider *prov)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">zebra_dplane_result</span> <span class="title">res</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zebra_dplane_ctx</span> *<span class="title">ctx</span>;</span></span><br><span class="line">    <span class="type">int</span> counter, limit;</span><br><span class="line">    limit = dplane_provider_get_work_limit(prov);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (counter = <span class="number">0</span>; counter &lt; limit; counter++) &#123;</span><br><span class="line">        ctx = dplane_provider_dequeue_in_ctx(prov);</span><br><span class="line">        <span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* A previous provider plugin may have asked to skip the kernel update.  */</span></span><br><span class="line">        <span class="keyword">if</span> (dplane_ctx_is_skip_kernel(ctx)) &#123;</span><br><span class="line">            res = ZEBRA_DPLANE_REQUEST_SUCCESS;</span><br><span class="line">            <span class="keyword">goto</span> skip_one;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Dispatch to appropriate kernel-facing apis */</span></span><br><span class="line">        <span class="keyword">switch</span> (dplane_ctx_get_op(ctx)) &#123;</span><br><span class="line">        <span class="keyword">case</span> DPLANE_OP_ROUTE_INSTALL:</span><br><span class="line">        <span class="keyword">case</span> DPLANE_OP_ROUTE_UPDATE:</span><br><span class="line">        <span class="keyword">case</span> DPLANE_OP_ROUTE_DELETE:</span><br><span class="line">            res = kernel_dplane_route_update(ctx);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">enum</span> zebra_dplane_result</span><br><span class="line"><span class="title function_">kernel_dplane_route_update</span><span class="params">(<span class="keyword">struct</span> zebra_dplane_ctx *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">zebra_dplane_result</span> <span class="title">res</span>;</span></span><br><span class="line">    <span class="comment">/* Call into the synchronous kernel-facing code here */</span></span><br><span class="line">    res = kernel_route_update(ctx);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而<code>kernel_route_update</code>则是真正的内核操作了，它会通过netlink来通知内核路由更新：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: src/sonic-frr/frr/zebra/rt_netlink.c</span></span><br><span class="line"><span class="comment">// Update or delete a prefix from the kernel, using info from a dataplane context.</span></span><br><span class="line"><span class="keyword">enum</span> zebra_dplane_result <span class="title function_">kernel_route_update</span><span class="params">(<span class="keyword">struct</span> zebra_dplane_ctx *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cmd, ret;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">prefix</span> *<span class="title">p</span> =</span> dplane_ctx_get_dest(ctx);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nexthop</span> *<span class="title">nexthop</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dplane_ctx_get_op(ctx) == DPLANE_OP_ROUTE_DELETE) &#123;</span><br><span class="line">        cmd = RTM_DELROUTE;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dplane_ctx_get_op(ctx) == DPLANE_OP_ROUTE_INSTALL) &#123;</span><br><span class="line">        cmd = RTM_NEWROUTE;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dplane_ctx_get_op(ctx) == DPLANE_OP_ROUTE_UPDATE) &#123;</span><br><span class="line">        cmd = RTM_NEWROUTE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!RSYSTEM_ROUTE(dplane_ctx_get_type(ctx)))</span><br><span class="line">        ret = netlink_route_multipath(cmd, ctx);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (ret == <span class="number">0</span> ? ZEBRA_DPLANE_REQUEST_SUCCESS : ZEBRA_DPLANE_REQUEST_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Routing table change via netlink interface, using a dataplane context object</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">netlink_route_multipath</span><span class="params">(<span class="type">int</span> cmd, <span class="keyword">struct</span> zebra_dplane_ctx *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Build netlink request.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> <span class="title">n</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rtmsg</span> <span class="title">r</span>;</span></span><br><span class="line">        <span class="type">char</span> buf[NL_PKT_BUF_SIZE];</span><br><span class="line">    &#125; req;</span><br><span class="line"></span><br><span class="line">    req.n.nlmsg_len = NLMSG_LENGTH(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> rtmsg));</span><br><span class="line">    req.n.nlmsg_flags = NLM_F_CREATE | NLM_F_REQUEST;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Talk to netlink socket. */</span></span><br><span class="line">    <span class="keyword">return</span> netlink_talk_info(netlink_talk_filter, &amp;req.n, dplane_ctx_get_ns(ctx), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="FPM路由更新转发">3.1.2.2. FPM路由更新转发</h5>
<p>FPM（Forwarding Plane Manager）是FRR中用于通知其他进程路由变更的协议，其主要逻辑代码在<code>src/sonic-frr/frr/zebra/zebra_fpm.c</code>中。它默认有两套协议实现：protobuf和netlink，SONiC就是使用的是netlink协议。</p>
<p>上面我们已经提到，它通过钩子函数实现，监听RIB中的路由变化，并通过本地Socket转发给其他的进程。这个钩子会在启动的时候就注册好，其中和我们现在看的最相关的就是<code>rib_update</code>钩子了，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">zebra_fpm_module_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    hook_register(rib_update, zfpm_trigger_update);</span><br><span class="line">    hook_register(zebra_rmac_update, zfpm_trigger_rmac_update);</span><br><span class="line">    hook_register(frr_late_init, zfpm_init);</span><br><span class="line">    hook_register(frr_early_fini, zfpm_fini);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FRR_MODULE_SETUP(.name = <span class="string">&quot;zebra_fpm&quot;</span>, .version = FRR_VERSION,</span><br><span class="line">         .description = <span class="string">&quot;zebra FPM (Forwarding Plane Manager) module&quot;</span>,</span><br><span class="line">         .init = zebra_fpm_module_init,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>当<code>rib_update</code>钩子被调用时，<code>zfpm_trigger_update</code>函数会被调用，它会将路由变更信息再次放入fpm的转发队列中，并触发写操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">zfpm_trigger_update</span><span class="params">(<span class="keyword">struct</span> route_node *rn, <span class="type">const</span> <span class="type">char</span> *reason)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rib_dest_t</span> *dest;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Queue the update request</span></span><br><span class="line">    dest = rib_dest_from_rnode(rn);</span><br><span class="line">    SET_FLAG(dest-&gt;flags, RIB_DEST_UPDATE_FPM);</span><br><span class="line">    TAILQ_INSERT_TAIL(&amp;zfpm_g-&gt;dest_q, dest, fpm_q_entries);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    zfpm_write_on();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">zfpm_write_on</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    thread_add_write(zfpm_g-&gt;master, zfpm_write_cb, <span class="number">0</span>, zfpm_g-&gt;sock, &amp;zfpm_g-&gt;t_write);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个写操作的回调就会将其从队列中取出，并转换成FPM的消息格式，然后通过本地Socket转发给其他进程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">zfpm_write_cb</span><span class="params">(<span class="keyword">struct</span> thread *thread)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stream</span> *<span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">int</span> bytes_to_write, bytes_written;</span><br><span class="line">        s = zfpm_g-&gt;obuf;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Convert route info to buffer here.</span></span><br><span class="line">        <span class="keyword">if</span> (stream_empty(s)) zfpm_build_updates();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write to socket until we don&#x27; have anything to write or cannot write anymore (partial write).</span></span><br><span class="line">        bytes_to_write = stream_get_endp(s) - stream_get_getp(s);</span><br><span class="line">        bytes_written = write(zfpm_g-&gt;sock, stream_pnt(s), bytes_to_write);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zfpm_writes_pending()) zfpm_write_on();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">zfpm_build_updates</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stream</span> *<span class="title">s</span> =</span> zfpm_g-&gt;obuf;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">/* Stop processing the queues if zfpm_g-&gt;obuf is full or we do not have more updates to process */</span></span><br><span class="line">        <span class="keyword">if</span> (zfpm_build_mac_updates() == FPM_WRITE_STOP) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (zfpm_build_route_updates() == FPM_WRITE_STOP) <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (zfpm_updates_pending());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此，FRR的工作就完成了。</p>
<h2 id="小结">4. 小结</h2>
<p>我们这一篇大概总结了SONiC和BGP相关的进程，BGP命令的实现思路，和它是如何通过FRR实现BGP路由的。下次，我们会继续介绍SONiC中FRR之后的BGP变更工作流。</p>
<h2 id="参考资料">5. 参考资料</h2>
<ol>
<li><a target="_blank" rel="noopener" href="https://github.com/sonic-net/SONiC/wiki/Architecture">SONiC Architecture</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/sonic-net/sonic-swss">Github repo: sonic-swss</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/sonic-net/sonic-swss-common">Github repo: sonic-swss-common</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/sonic-net/sonic-frr">Github repo: sonic-frr</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/sonic-net/sonic-utilities">Github repo: sonic-utilities</a></li>
<li><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc4271">RFC 4271: A Border Gateway Protocol 4 (BGP-4)</a></li>
<li><a target="_blank" rel="noopener" href="https://frrouting.org/">FRRouting</a></li>
</ol>
<hr>
<div class="post-series"><div class="post-series-title">同系列文章：</div><ul class="post-series-list"><li class="post-series-list-item"><a href="http://r12f.com/posts/sonic-7-bgp-workflow-part-2/">SONiC学习笔记（七）：BGP工作流（下）—— BGP路由变更下发</a></li><li class="post-series-list-item"><a href="http://r12f.com/posts/sonic-6-bgp-workflow-part-1/">SONiC学习笔记（六）：BGP工作流（上）—— 命令实现与FRR</a></li><li class="post-series-list-item"><a href="http://r12f.com/posts/sonic-5-syncd-sai-workflow/">SONiC学习笔记（五）：Syncd-SAI工作流</a></li><li class="post-series-list-item"><a href="http://r12f.com/posts/sonic-4-communication/">SONiC学习笔记（四）：通信机制</a></li><li class="post-series-list-item"><a href="http://r12f.com/posts/sonic-3-code-repos/">SONiC学习笔记（三）：代码仓库</a></li><li class="post-series-list-item"><a href="http://r12f.com/posts/sonic-2-key-components/">SONiC学习笔记（二）：核心组件</a></li><li class="post-series-list-item"><a href="http://r12f.com/posts/sonic-1-intro/">SONiC学习笔记（一）：概述与安装</a></li></ul></div>
<b>原创文章，转载请标明出处：</b><a href="http://r12f.com" target="_blank">Soul Orbit</a><br><b>本文链接地址：</b><a href="http://r12f.com/posts/sonic-6-bgp-workflow-part-1/" target="_blank">SONiC学习笔记（六）：BGP工作流（上）—— 命令实现与FRR</a>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/network/" rel="tag"># network</a>
              <a href="/tags/nos/" rel="tag"># nos</a>
              <a href="/tags/sonic/" rel="tag"># sonic</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/sonic-5-syncd-sai-workflow/" rel="prev" title="SONiC学习笔记（五）：Syncd-SAI工作流">
                  <i class="fa fa-chevron-left"></i> SONiC学习笔记（五）：Syncd-SAI工作流
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/sonic-7-bgp-workflow-part-2/" rel="next" title="SONiC学习笔记（七）：BGP工作流（下）—— BGP路由变更下发">
                  SONiC学习笔记（七）：BGP工作流（下）—— BGP路由变更下发 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2011 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">r12f</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.4.3/mermaid.min.js","integrity":"sha256-e0o3JYsdjqKajf9eOe22FhioYSz9WofRY4dLKo3F6do="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>

  <script class="next-config" data-name="wavedrom" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.2.0/wavedrom.min.js","integrity":"sha512-/ZL0uQxVV1wYyWlpO4klZ1a39eaBz4zESSamuBMaMsZ6le3YejJ07hmLlHoCTXrKz5eYtEuO5K1BcTo+lQpQJA=="}}</script>
  <script class="next-config" data-name="wavedrom_skin" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.2.0/skins/default.js","integrity":"sha512-GV5gOBpCHd3M5Af9Ooz+I9dQdwcDKPR2F8ulzCpoF4W6uwmtLTh/pT8Q1XupPmQJO+Kt88/DrIiK7PzR1YLvwQ=="}}</script>
  <script src="/js/third-party/tags/wavedrom.js"></script>




  


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"aanH10fNtc25mqFK1gSRqjo9-gzGzoHsz","app_key":"4AhjDuBCXDyUgpY0Cvh4wEol","server_url":"https://aanh10fn.lc-cn-n1-shared.com","security":false}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>


  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"r12f-blog","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
